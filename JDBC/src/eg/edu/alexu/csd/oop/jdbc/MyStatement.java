package eg.edu.alexu.csd.oop.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;

import eg.edu.alexu.csd.oop.jdbc.engine.Engine;
import eg.edu.alexu.csd.oop.jdbc.log4j.Log4jLogger;
import eg.edu.alexu.csd.oop.jdbc.query.code.QueryRunnableCode;
import eg.edu.alexu.csd.oop.jdbc.sql.parser.MyEntry;
import eg.edu.alexu.csd.oop.jdbc.sql.parser.QueryValidatorAndParser;

/**
 * The Class StatementImp.
 */

public class MyStatement implements Statement {

  private Engine currentEngine;
  private Connection currentConnection;
  private ArrayList<MyEntry<String, Integer>> batchList;
  private int time;
  private QueryValidatorAndParser queryValidatorAndParser;
  private boolean isClosed;

  public MyStatement(Engine engine, Connection conct) {
    isClosed = false;
    currentEngine = engine;
    currentConnection = conct;
    batchList = new ArrayList<MyEntry<String, Integer>>();
    time = Integer.MAX_VALUE; // means no limit
    queryValidatorAndParser = new QueryValidatorAndParser();
    Log4jLogger.log.debug("Create new Statement");
  }

  @Override
  public boolean isWrapperFor(Class<?> iface) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public <T> T unwrap(Class<T> iface) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void addBatch(String sql) throws SQLException {
    // check that sql query is correct and then add it to listarray
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      int type = queryValidatorAndParser.isValidQuery(sql);
      batchList.add(new MyEntry<String, Integer>(sql, type));
      Log4jLogger.log.info(sql);
      Log4jLogger.log.debug(sql + " - added to batchList");
    }

  }

  @Override
  public void cancel() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void clearBatch() throws SQLException {
    // Clear the list
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      batchList.clear();
      Log4jLogger.log.debug("batchList now clear");
    }

  }

  @Override
  public void clearWarnings() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void close() throws SQLException {
    isClosed = true;
    Log4jLogger.log.debug("Statement now is closed");
  }

  @Override
  public void closeOnCompletion() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean execute(String sql) throws SQLException {
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      Log4jLogger.log.info(sql);
      QueryRunnableCode queryCode = new QueryRunnableCode(currentEngine,
      QueryRunnableCode.generalQuery, this, sql, queryValidatorAndParser);
      Thread queryThread = new Thread(queryCode);
      queryThread.start();
      Log4jLogger.log.debug("The Thread Time Started");
      try {
        queryThread.join(((long) time) * 1000);
        if (queryThread.isAlive()) {
          queryThread.interrupt();
          Log4jLogger.log.error(new RuntimeException("query timed-out"));
          throw new RuntimeException("query timed-out");
        }
      } catch (InterruptedException e) {
        // shouldn't happen
      }
      // execution continued normally
      // an sql exception may be throw on executing this statement
      Log4jLogger.log.debug(queryCode.getExecutionResult());
      return queryCode.getExecutionResult();
    }
  }

  @Override
  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean execute(String sql, int[] columnIndexes) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean execute(String sql, String[] columnNames) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int[] executeBatch() throws SQLException {
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      Log4jLogger.log.debug("Execute Batch begin");
      int[] updateCount = new int[batchList.size()];
      int counter = 0;
      for (MyEntry<String, Integer> query : batchList) {
        String sql = query.getFirst();
        int type = query.getSecond();
        if (type == QueryValidatorAndParser.structueQuery) {
          execute(sql);
        } else if (type == QueryValidatorAndParser.updateQuery) {
          updateCount[counter] = executeUpdate(sql);
        } else if (type == QueryValidatorAndParser.selectionQuery) {
          executeQuery(sql);
        }
        counter++;
      }
      return updateCount;
    }

  }

  @Override
  public ResultSet executeQuery(String sql) throws SQLException {
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      Log4jLogger.log.info(sql);
      QueryRunnableCode queryCode = new QueryRunnableCode(currentEngine,
      QueryRunnableCode.selectionQuery, this, sql, queryValidatorAndParser);
      Thread queryThread = new Thread(queryCode);
      queryThread.start();
      Log4jLogger.log.debug("The Thread Time Started");
      try {
        queryThread.join(((long) time) * 1000);
        if (queryThread.isAlive()) {
          queryThread.interrupt();
          Log4jLogger.log.error(new RuntimeException("query timed-out"));
          throw new RuntimeException("query timed-out");
        }
      } catch (InterruptedException e) {
        // shouldn't happen
      }
      // execution continued normally
      // an sql exception may be thrown right here
      Log4jLogger.log.debug("The SQL is now executed");
      return queryCode.getResultSetExecutionResult();
    }

  }

  @Override
  public int executeUpdate(String sql) throws SQLException {
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      Log4jLogger.log.info(sql);
      QueryRunnableCode queryCode = new QueryRunnableCode(currentEngine,
      QueryRunnableCode.updateQuery, this, sql, queryValidatorAndParser);
      Thread queryThread = new Thread(queryCode);
      queryThread.start();
      Log4jLogger.log.debug("The Thread Time Started");
      try {
        queryThread.join(((long) time) * 1000);
        if (queryThread.isAlive()) {
          queryThread.interrupt();
          Log4jLogger.log.error(new RuntimeException("query timed-out"));
          throw new RuntimeException("query timed-out");
        }
      } catch (InterruptedException e) {
        // shouldn't happen
      }
      // execution continued normally
      // an sql exception may be thrown right here
      Log4jLogger.log.debug(queryCode.getIntegerExecutionResult());
      return queryCode.getIntegerExecutionResult();
    }
  }

  @Override
  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int executeUpdate(String sql, String[] columnNames) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public Connection getConnection() throws SQLException {
    return this.currentConnection;
  }

  @Override
  public int getFetchDirection() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getFetchSize() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public ResultSet getGeneratedKeys() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getMaxFieldSize() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getMaxRows() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean getMoreResults() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean getMoreResults(int current) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getQueryTimeout() throws SQLException {
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      Log4jLogger.log.debug("Query Time is " + this.time);
      return this.time;
    }

  }

  @Override
  public ResultSet getResultSet() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getResultSetConcurrency() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getResultSetHoldability() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getResultSetType() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public int getUpdateCount() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public SQLWarning getWarnings() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean isCloseOnCompletion() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean isClosed() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public boolean isPoolable() throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setCursorName(String name) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setEscapeProcessing(boolean enable) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setFetchDirection(int direction) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setFetchSize(int rows) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setMaxFieldSize(int max) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setMaxRows(int max) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setPoolable(boolean poolable) throws SQLException {

    throw new java.lang.UnsupportedOperationException();
  }

  @Override
  public void setQueryTimeout(int seconds) throws SQLException {
    if (isClosed) {
      Log4jLogger.log.error("The Statement is Closed");
      throw new SQLException();
    } else {
      Log4jLogger.log.info(seconds);
      if (seconds > Integer.MAX_VALUE / 1000 || seconds <= 0) {
        Log4jLogger.log.error(new IllegalArgumentException());
        throw new IllegalArgumentException();
      }
      Log4jLogger.log.debug("The Query time is now " + seconds);
      this.time = seconds;
    }

  }

}
